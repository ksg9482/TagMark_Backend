# TAG-MARK

## 기획
인터넷을 검색하다가 내용을 탭으로 열어서 보다 보면 탭이 어느샌가 수십개가 넘어가곤 합니다. 저도 그것은 마찬가지라 분명 찾아서 열었던 사이트를 다시 찾으려고 탭을 뒤적입니다. 그래서 탭을 좀 정리하려고 하면 나중에 보려고 북마크에 저장해 버립니다. 이것을 몇 번 반복하다 보면 북마크는 북마크대로 넘쳐나고 탭은 탭대로 가득 차는 결말을 맞습니다. 

심지어 북마크 내용이 일부는 중복되고 일부는 도대체 내가 이걸 왜 북마크 해놓았는지 모르게되는 경우도 있습니다. 그렇다면 차라리 북마크를 제대로 정리하자, 폴더로 정리하면 폴더만 우후죽순 늘어날거 같으니 태그로 관리할 수 있게 하자는 생각이 들었습니다. 그렇게 하여 북마크에 태크를 지정하고 태그 기반으로 북마크를 관리할 수 있는 사이트를 구상하게 되었습니다.

___

## 백엔드
* 태그 기반 검색을 위해 태그 OR/AND 쿼리 작성
* 보안 및 로그인 유지를 위해 JWT(Json Web Token)을 이용한 Access Token, Refresh Token 설정 
* Google 소셜 로그인 구현
* Swagger를 이용한 API 명세서 작성
* NGINX를 WS로 두어 WS-WAS 분리 및 리버스 프록시 적용
* AWS를 통해 HTTPS 웹사이트 배포
* E2E 테스트 작성

### 기술 스택
* NestJS
  * 이전부터 아키텍처에 관심이 많아 여러가지 아키텍처를 시도해 보았습니다. nodejs 진영 프레임워크에서는 nestjs가 아키텍처에 대한 기준을 가지고 있었고, nestjs가 제안하는 모듈기반 아키텍처를 경험해보고 싶었기 때문에 프레임워크로 nestjs를 선택했습니다.
* PostgreSQL
  * mysql과 문법도 비슷해서 익히기 쉬웠고, 최근 트렌드를 따라간 면도 있었습니다. 하지만 가장 큰 이유는 많은 양의 북마크를 동기화하거나 다양한 태그 기반 검색 등 복잡한 쿼리나 많은 양의 데이터를 처리하는데 postgresql이 이점이 있기 때문입니다.
* Nginx
  * WS와 WAS 분리하고 리버스 프록시를 적용하여 WAS를 보호하기 위해 도입했습니다, 아파치도 선택지에 있었지만 nginx가 성능이 좋고 가벼워 처리가 빼르기 때문에 nginx를 선택했습니다.
* Docker
  * 개발을 데스크탑과 노트북을 병행하기 때문에 개발환경이 서로 다릅니다. 그렇기에 같은 개발환경을 만들기 위해 도커를 이용했고, 어차피 배포할 때도 개발환경이 달라질 수 있기 때문에 환경설정과 관리를 쉽게 하기 위해 이용했습니다.
* AWS(S3, Cloud Front, EC2, Route53, RDS)
  * 다른 프로젝트를 진행했을 때는 다른 팀원이 배포를 맡거나, 헤로쿠 등의 서비스를 이용했었습니다. 이 Tagmark는 배포까지 제대로 진행해보자고 생각해 AWS를 이용하여 배포를 진행했습니다.

___

## 데이터베이스 테이블 구조
![tagmark_entities](https://user-images.githubusercontent.com/83062886/212309957-a1f19308-559a-4a0c-a626-40929ee2bd58.jpg)
___

## 시스템 아키텍처
![tagmark_architecture_rds_ver drawio](https://user-images.githubusercontent.com/83062886/215636681-907b575a-4e38-4ef3-b01e-8ad29758c6a8.jpg)
___

## API 명세
[Swagger](https://server.tagmark.site/api-docs)
* User
  * 회원가입
  * 로그인
  * 소셜 로그인
  * 회원 정보 수정
  * 로그아웃
  * 회원 탈퇴
* Bookmark
  * 북마크 생성
  * 북마크 수정
  * 작성한 북마크 가져오기
  * 북마크 삭제
* Tag
  * 태그 생성
  * 태그 수정
  * 태그 삭제
  * 태그 기반 검색

## 디렉토리 구성
* Core
  * 핵심부입니다. 추상클래스와 엔티티가 존재하고 Core는 프레임워크와 분리되어 있어서 프레임워크가 바뀌어도 수정할 부분이 적게 했습니다.
* Controllers
  * HTTP 요청을 해당 비즈니스 로직과 매칭하는 부분입니다. DTO를 이용하기에 Controllers에 DTO 디렉토리가 존재하며, 비즈니스 로직에 맞게 데이터 형식을 가공하여 use-case를 호출합니다.
* Frameworks
  * 엔티티를 기반으로 한 DB 테이블 모델이 존재하고, 데이터베이스 프레임워크를 통해 데이터베이스에 쿼리를 전송한다.
* Services
  * 데이터베이스와의 연결을 서비스로서 제공합니다.
* Use-cases
  * 설계한 비즈니스 로직으로 요청받은 데이터를 처리하여 처리가 완료된 데이터를 반환합니다.
* Utils
  * JWT, Logger, 예외처리 등 유틸리티를 관리합니다.
* Auth
  * 요청에 JWT의 존재 여부와 정합성을 확인하고, 요청한 유저ID를 요청에 삽입하여 @AuthUser 데코레이터를 사용할 수 있게 합니다.
___

## 미리보기
___

#### 후기
이 프로젝트는 실제로 더 발전시켜서 직접 사용할 계획이기 때문에 장기적인 리펙토링, 학습한 내용의 지속적인 적용을 염두에 두었습니다. 객체지향 패러다임과 함수형 패러다임 모두에 관심이 있기 때문에 백엔드에서는 NestJS를 통해 객체지향을 익히고, 프론트엔드에서 함수형 패러다임 적용을 염두에 두어 발전시키려고 합니다.

북마크 공유와 북마크 파일을 읽어오거나 하는 등의 새로운 기능을 추가하여 Ver.2를 개발하는 것이 이후의 목표입니다.

